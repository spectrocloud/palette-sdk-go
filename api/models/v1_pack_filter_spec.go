// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1PackFilterSpec Packs filter spec
//
// swagger:model v1PackFilterSpec
type V1PackFilterSpec struct {

	// Pack add-on sub type such as monitoring, db etc
	// Unique: true
	AddOnSubType []string `json:"addOnSubType"`

	// Pack add-on type such as logging, monitoring, security etc
	// Unique: true
	AddOnType []string `json:"addOnType"`

	// display name
	DisplayName *V1FilterString `json:"displayName,omitempty"`

	// Pack supported cloud types
	// Unique: true
	Environment []string `json:"environment"`

	// isFips compliant
	IsFips bool `json:"isFips,omitempty"`

	// Pack layer
	// Unique: true
	Layer []V1PackLayer `json:"layer"`

	// name
	Name *V1FilterString `json:"name,omitempty"`

	// Pack registry uid
	// Unique: true
	RegistryUID []string `json:"registryUid"`

	// The source filter describes the creation origin/source of the pack. Ex. source can be "spectrocloud" or "community"
	// Unique: true
	Source []string `json:"source"`

	// Pack state such as deprecated or disabled
	// Unique: true
	State []string `json:"state"`

	// Pack type
	// Unique: true
	Type []V1PackType `json:"type"`
}

// Validate validates this v1 pack filter spec
func (m *V1PackFilterSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddOnSubType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddOnType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLayer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegistryUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1PackFilterSpec) validateAddOnSubType(formats strfmt.Registry) error {

	if swag.IsZero(m.AddOnSubType) { // not required
		return nil
	}

	if err := validate.UniqueItems("addOnSubType", "body", m.AddOnSubType); err != nil {
		return err
	}

	return nil
}

func (m *V1PackFilterSpec) validateAddOnType(formats strfmt.Registry) error {

	if swag.IsZero(m.AddOnType) { // not required
		return nil
	}

	if err := validate.UniqueItems("addOnType", "body", m.AddOnType); err != nil {
		return err
	}

	return nil
}

func (m *V1PackFilterSpec) validateDisplayName(formats strfmt.Registry) error {

	if swag.IsZero(m.DisplayName) { // not required
		return nil
	}

	if m.DisplayName != nil {
		if err := m.DisplayName.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("displayName")
			}
			return err
		}
	}

	return nil
}

func (m *V1PackFilterSpec) validateEnvironment(formats strfmt.Registry) error {

	if swag.IsZero(m.Environment) { // not required
		return nil
	}

	if err := validate.UniqueItems("environment", "body", m.Environment); err != nil {
		return err
	}

	return nil
}

func (m *V1PackFilterSpec) validateLayer(formats strfmt.Registry) error {

	if swag.IsZero(m.Layer) { // not required
		return nil
	}

	if err := validate.UniqueItems("layer", "body", m.Layer); err != nil {
		return err
	}

	for i := 0; i < len(m.Layer); i++ {

		if err := m.Layer[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("layer" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

func (m *V1PackFilterSpec) validateName(formats strfmt.Registry) error {

	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if m.Name != nil {
		if err := m.Name.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("name")
			}
			return err
		}
	}

	return nil
}

func (m *V1PackFilterSpec) validateRegistryUID(formats strfmt.Registry) error {

	if swag.IsZero(m.RegistryUID) { // not required
		return nil
	}

	if err := validate.UniqueItems("registryUid", "body", m.RegistryUID); err != nil {
		return err
	}

	return nil
}

func (m *V1PackFilterSpec) validateSource(formats strfmt.Registry) error {

	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if err := validate.UniqueItems("source", "body", m.Source); err != nil {
		return err
	}

	return nil
}

func (m *V1PackFilterSpec) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	if err := validate.UniqueItems("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *V1PackFilterSpec) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := validate.UniqueItems("type", "body", m.Type); err != nil {
		return err
	}

	for i := 0; i < len(m.Type); i++ {

		if err := m.Type[i].Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("type" + "." + strconv.Itoa(i))
			}
			return err
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1PackFilterSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1PackFilterSpec) UnmarshalBinary(b []byte) error {
	var res V1PackFilterSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
