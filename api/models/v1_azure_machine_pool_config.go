// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1AzureMachinePoolConfig v1 azure machine pool config
//
// swagger:model v1AzureMachinePoolConfig
type V1AzureMachinePoolConfig struct {

	// additionalLabels
	AdditionalLabels map[string]string `json:"additionalLabels,omitempty"`

	// AdditionalTags is an optional set of tags to add to resources managed by the provider, in addition to the ones added by default. For eg., tags for EKS nodeGroup or EKS NodegroupIAMRole
	AdditionalTags map[string]string `json:"additionalTags,omitempty"`

	// azs
	Azs []string `json:"azs"`

	// instance config
	InstanceConfig *V1InstanceConfig `json:"instanceConfig,omitempty"`

	// Instance type stands for VMSize in Azure
	InstanceType string `json:"instanceType,omitempty"`

	// whether this pool is for control plane
	// Required: true
	IsControlPlane *bool `json:"isControlPlane"`

	// whether this pool is for system node Pool
	IsSystemNodePool bool `json:"isSystemNodePool"`

	// labels for this pool, example: control-plane/worker, gpu, windows
	Labels []string `json:"labels"`

	// machine pool properties
	MachinePoolProperties *V1MachinePoolProperties `json:"machinePoolProperties,omitempty"`

	// max size of the pool, for scaling
	MaxSize int32 `json:"maxSize,omitempty"`

	// min size of the pool, for scaling
	MinSize int32 `json:"minSize,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// Minimum number of seconds a node should be Ready, before the next node is selected for repave. Applicable only for workerpools in infrastructure cluster
	NodeRepaveInterval int32 `json:"nodeRepaveInterval,omitempty"`

	// os disk
	OsDisk *V1AzureOSDisk `json:"osDisk,omitempty"`

	// os type
	OsType *V1OsType `json:"osType,omitempty"`

	// size of the pool, number of machines
	Size int32 `json:"size,omitempty"`

	// SpotVMOptions allows the ability to specify the Machine should use a Spot VM
	SpotVMOptions *V1SpotVMOptions `json:"spotVMOptions,omitempty"`

	// control plane or worker taints
	// Unique: true
	Taints []*V1Taint `json:"taints"`

	// rolling update strategy for this machinepool if not specified, will use ScaleOut
	UpdateStrategy *V1UpdateStrategy `json:"updateStrategy,omitempty"`

	// if IsControlPlane==true && useControlPlaneAsWorker==true, then will remove control plane taint this will not be used for worker pools
	UseControlPlaneAsWorker bool `json:"useControlPlaneAsWorker"`
}

// Validate validates this v1 azure machine pool config
func (m *V1AzureMachinePoolConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateInstanceConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsControlPlane(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMachinePoolProperties(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsDisk(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOsType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSpotVMOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaints(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateStrategy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1AzureMachinePoolConfig) validateInstanceConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.InstanceConfig) { // not required
		return nil
	}

	if m.InstanceConfig != nil {
		if err := m.InstanceConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instanceConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instanceConfig")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateIsControlPlane(formats strfmt.Registry) error {

	if err := validate.Required("isControlPlane", "body", m.IsControlPlane); err != nil {
		return err
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateMachinePoolProperties(formats strfmt.Registry) error {
	if swag.IsZero(m.MachinePoolProperties) { // not required
		return nil
	}

	if m.MachinePoolProperties != nil {
		if err := m.MachinePoolProperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("machinePoolProperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("machinePoolProperties")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateOsDisk(formats strfmt.Registry) error {
	if swag.IsZero(m.OsDisk) { // not required
		return nil
	}

	if m.OsDisk != nil {
		if err := m.OsDisk.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("osDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("osDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateOsType(formats strfmt.Registry) error {
	if swag.IsZero(m.OsType) { // not required
		return nil
	}

	if m.OsType != nil {
		if err := m.OsType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("osType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("osType")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateSpotVMOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.SpotVMOptions) { // not required
		return nil
	}

	if m.SpotVMOptions != nil {
		if err := m.SpotVMOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spotVMOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spotVMOptions")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateTaints(formats strfmt.Registry) error {
	if swag.IsZero(m.Taints) { // not required
		return nil
	}

	if err := validate.UniqueItems("taints", "body", m.Taints); err != nil {
		return err
	}

	for i := 0; i < len(m.Taints); i++ {
		if swag.IsZero(m.Taints[i]) { // not required
			continue
		}

		if m.Taints[i] != nil {
			if err := m.Taints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taints" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1AzureMachinePoolConfig) validateUpdateStrategy(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdateStrategy) { // not required
		return nil
	}

	if m.UpdateStrategy != nil {
		if err := m.UpdateStrategy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateStrategy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateStrategy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this v1 azure machine pool config based on the context it is used
func (m *V1AzureMachinePoolConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateInstanceConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMachinePoolProperties(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOsDisk(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOsType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSpotVMOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTaints(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUpdateStrategy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateInstanceConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.InstanceConfig != nil {

		if swag.IsZero(m.InstanceConfig) { // not required
			return nil
		}

		if err := m.InstanceConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instanceConfig")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instanceConfig")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateMachinePoolProperties(ctx context.Context, formats strfmt.Registry) error {

	if m.MachinePoolProperties != nil {

		if swag.IsZero(m.MachinePoolProperties) { // not required
			return nil
		}

		if err := m.MachinePoolProperties.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("machinePoolProperties")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("machinePoolProperties")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateOsDisk(ctx context.Context, formats strfmt.Registry) error {

	if m.OsDisk != nil {

		if swag.IsZero(m.OsDisk) { // not required
			return nil
		}

		if err := m.OsDisk.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("osDisk")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("osDisk")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateOsType(ctx context.Context, formats strfmt.Registry) error {

	if m.OsType != nil {

		if swag.IsZero(m.OsType) { // not required
			return nil
		}

		if err := m.OsType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("osType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("osType")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateSpotVMOptions(ctx context.Context, formats strfmt.Registry) error {

	if m.SpotVMOptions != nil {

		if swag.IsZero(m.SpotVMOptions) { // not required
			return nil
		}

		if err := m.SpotVMOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("spotVMOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("spotVMOptions")
			}
			return err
		}
	}

	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateTaints(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Taints); i++ {

		if m.Taints[i] != nil {

			if swag.IsZero(m.Taints[i]) { // not required
				return nil
			}

			if err := m.Taints[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taints" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1AzureMachinePoolConfig) contextValidateUpdateStrategy(ctx context.Context, formats strfmt.Registry) error {

	if m.UpdateStrategy != nil {

		if swag.IsZero(m.UpdateStrategy) { // not required
			return nil
		}

		if err := m.UpdateStrategy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("updateStrategy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("updateStrategy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1AzureMachinePoolConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1AzureMachinePoolConfig) UnmarshalBinary(b []byte) error {
	var res V1AzureMachinePoolConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
