// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1VMInterface v1 Vm interface
//
// swagger:model v1VmInterface
type V1VMInterface struct {

	// If specified, the ACPI index is used to provide network interface device naming, that is stable across changes in PCI addresses assigned to the device. This value is required to be unique across all devices and be between 1 and (16*1024-1).
	AcpiIndex int32 `json:"acpiIndex,omitempty"`

	// BootOrder is an integer value > 0, used to determine ordering of boot devices. Lower values take precedence. Each interface or disk that has a boot order must have a unique value. Interfaces without a boot order are not tried.
	BootOrder int32 `json:"bootOrder,omitempty"`

	// bridge
	Bridge V1VMInterfaceBridge `json:"bridge,omitempty"`

	// dhcp options
	DhcpOptions *V1VMDHCPOptions `json:"dhcpOptions,omitempty"`

	// Interface MAC address. For example: de:ad:00:00:be:af or DE-AD-00-00-BE-AF.
	MacAddress string `json:"macAddress,omitempty"`

	// macvtap
	Macvtap V1VMInterfaceMacvtap `json:"macvtap,omitempty"`

	// masquerade
	Masquerade V1VMInterfaceMasquerade `json:"masquerade,omitempty"`

	// Interface model. One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
	Model string `json:"model,omitempty"`

	// Logical name of the interface as well as a reference to the associated networks. Must match the Name of a Network.
	// Required: true
	Name *string `json:"name"`

	// passt
	Passt V1VMInterfacePasst `json:"passt,omitempty"`

	// If specified, the virtual network interface will be placed on the guests pci address with the specified PCI address. For example: 0000:81:01.10
	PciAddress string `json:"pciAddress,omitempty"`

	// List of ports to be forwarded to the virtual machine.
	Ports []*V1VMPort `json:"ports"`

	// slirp
	Slirp V1VMInterfaceSlirp `json:"slirp,omitempty"`

	// sriov
	Sriov V1VMInterfaceSRIOV `json:"sriov,omitempty"`

	// If specified, the virtual network interface address and its tag will be provided to the guest via config drive
	Tag string `json:"tag,omitempty"`
}

// Validate validates this v1 Vm interface
func (m *V1VMInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDhcpOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1VMInterface) validateDhcpOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.DhcpOptions) { // not required
		return nil
	}

	if m.DhcpOptions != nil {
		if err := m.DhcpOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dhcpOptions")
			}
			return err
		}
	}

	return nil
}

func (m *V1VMInterface) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *V1VMInterface) validatePorts(formats strfmt.Registry) error {

	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1VMInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1VMInterface) UnmarshalBinary(b []byte) error {
	var res V1VMInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
