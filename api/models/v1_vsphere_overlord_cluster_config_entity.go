// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V1VsphereOverlordClusterConfigEntity v1 vsphere overlord cluster config entity
//
// swagger:model v1VsphereOverlordClusterConfigEntity
type V1VsphereOverlordClusterConfigEntity struct {

	// The optional control plane endpoint, which can be an IP or FQDN
	ControlPlaneEndpoint *V1ControlPlaneEndPoint `json:"controlPlaneEndpoint,omitempty"`

	// NTPServers is a list of NTP servers to use instead of the machine image's default NTP server list.
	NtpServers []string `json:"ntpServers"`

	// Placements configuration Placements If defined, will replace default values defined in VsphereClusterConfig Array means one MachinePool can span across multiple vsphere compute cluster
	Placements []*V1VspherePlacementConfigEntity `json:"placements"`

	// SSHKeys specifies a list of ssh authorized keys for the 'spectro' user
	SSHKeys []string `json:"sshKeys"`

	// whether this cluster should use dhcp or static IP, if false, use DHCP if this is set, then all machinepools should have staticIP with provided IPPool adding this as an additional standalone flag without relating to placement.Nework main reason is to enable more validation for placement.Network.StaticIP which should come together with valid Network.IPPool and Network.Name
	StaticIP bool `json:"staticIp,omitempty"`
}

// Validate validates this v1 vsphere overlord cluster config entity
func (m *V1VsphereOverlordClusterConfigEntity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateControlPlaneEndpoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlacements(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1VsphereOverlordClusterConfigEntity) validateControlPlaneEndpoint(formats strfmt.Registry) error {

	if swag.IsZero(m.ControlPlaneEndpoint) { // not required
		return nil
	}

	if m.ControlPlaneEndpoint != nil {
		if err := m.ControlPlaneEndpoint.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("controlPlaneEndpoint")
			}
			return err
		}
	}

	return nil
}

func (m *V1VsphereOverlordClusterConfigEntity) validatePlacements(formats strfmt.Registry) error {

	if swag.IsZero(m.Placements) { // not required
		return nil
	}

	for i := 0; i < len(m.Placements); i++ {
		if swag.IsZero(m.Placements[i]) { // not required
			continue
		}

		if m.Placements[i] != nil {
			if err := m.Placements[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("placements" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1VsphereOverlordClusterConfigEntity) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1VsphereOverlordClusterConfigEntity) UnmarshalBinary(b []byte) error {
	var res V1VsphereOverlordClusterConfigEntity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
