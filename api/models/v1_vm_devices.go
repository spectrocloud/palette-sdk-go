// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// V1VMDevices v1 Vm devices
//
// swagger:model v1VmDevices
type V1VMDevices struct {

	// Whether to attach the default graphics device or not. VNC will not be available if set to false. Defaults to true.
	AutoattachGraphicsDevice bool `json:"autoattachGraphicsDevice,omitempty"`

	// Whether to attach an Input Device. Defaults to false.
	AutoattachInputDevice bool `json:"autoattachInputDevice,omitempty"`

	// Whether to attach the Memory balloon device with default period. Period can be adjusted in virt-config. Defaults to true.
	AutoattachMemBalloon bool `json:"autoattachMemBalloon,omitempty"`

	// Whether to attach a pod network interface. Defaults to true.
	AutoattachPodInterface bool `json:"autoattachPodInterface,omitempty"`

	// Whether to attach the default serial console or not. Serial console access will not be available if set to false. Defaults to true.
	AutoattachSerialConsole bool `json:"autoattachSerialConsole,omitempty"`

	// Whether to attach the VSOCK CID to the VM or not. VSOCK access will be available if set to true. Defaults to false.
	AutoattachVSOCK bool `json:"autoattachVSOCK,omitempty"`

	// Whether or not to enable virtio multi-queue for block devices. Defaults to false.
	BlockMultiQueue bool `json:"blockMultiQueue,omitempty"`

	// client passthrough
	ClientPassthrough V1VMClientPassthroughDevices `json:"clientPassthrough,omitempty"`

	// DisableHotplug disabled the ability to hotplug disks.
	DisableHotplug bool `json:"disableHotplug,omitempty"`

	// Disks describes disks, cdroms and luns which are connected to the vmi.
	Disks []*V1VMDisk `json:"disks"`

	// DownwardMetrics creates a virtio serials for exposing the downward metrics to the vmi.
	DownwardMetrics interface{} `json:"downwardMetrics,omitempty"`

	// Filesystems describes filesystem which is connected to the vmi.
	Filesystems []*V1VMFilesystem `json:"filesystems"`

	// Whether to attach a GPU device to the vmi.
	Gpus []*V1VMGPU `json:"gpus"`

	// Whether to attach a host device to the vmi.
	HostDevices []*V1VMHostDevice `json:"hostDevices"`

	// Inputs describe input devices
	Inputs []*V1VMInput `json:"inputs"`

	// Interfaces describe network interfaces which are added to the vmi.
	Interfaces []*V1VMInterface `json:"interfaces"`

	// Whether to log the auto-attached default serial console or not. Serial console logs will be collect to a file and then streamed from a named 'guest-console-log'. Not relevant if autoattachSerialConsole is disabled. Defaults to cluster wide setting on VirtualMachineOptions.
	LogSerialConsole bool `json:"logSerialConsole,omitempty"`

	// If specified, virtual network interfaces configured with a virtio bus will also enable the vhost multiqueue feature for network devices. The number of queues created depends on additional factors of the VirtualMachineInstance, like the number of guest CPUs.
	NetworkInterfaceMultiqueue bool `json:"networkInterfaceMultiqueue,omitempty"`

	// rng
	Rng V1VMRng `json:"rng,omitempty"`

	// sound
	Sound *V1VMSoundDevice `json:"sound,omitempty"`

	// tpm
	Tpm V1VMTPMDevice `json:"tpm,omitempty"`

	// Fall back to legacy virtio 0.9 support if virtio bus is selected on devices. This is helpful for old machines like CentOS6 or RHEL6 which do not understand virtio_non_transitional (virtio 1.0).
	UseVirtioTransitional bool `json:"useVirtioTransitional,omitempty"`

	// watchdog
	Watchdog *V1VMWatchdog `json:"watchdog,omitempty"`
}

// Validate validates this v1 Vm devices
func (m *V1VMDevices) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDisks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesystems(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostDevices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInputs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSound(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWatchdog(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1VMDevices) validateDisks(formats strfmt.Registry) error {
	if swag.IsZero(m.Disks) { // not required
		return nil
	}

	for i := 0; i < len(m.Disks); i++ {
		if swag.IsZero(m.Disks[i]) { // not required
			continue
		}

		if m.Disks[i] != nil {
			if err := m.Disks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("disks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("disks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) validateFilesystems(formats strfmt.Registry) error {
	if swag.IsZero(m.Filesystems) { // not required
		return nil
	}

	for i := 0; i < len(m.Filesystems); i++ {
		if swag.IsZero(m.Filesystems[i]) { // not required
			continue
		}

		if m.Filesystems[i] != nil {
			if err := m.Filesystems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("filesystems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("filesystems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) validateGpus(formats strfmt.Registry) error {
	if swag.IsZero(m.Gpus) { // not required
		return nil
	}

	for i := 0; i < len(m.Gpus); i++ {
		if swag.IsZero(m.Gpus[i]) { // not required
			continue
		}

		if m.Gpus[i] != nil {
			if err := m.Gpus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gpus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("gpus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) validateHostDevices(formats strfmt.Registry) error {
	if swag.IsZero(m.HostDevices) { // not required
		return nil
	}

	for i := 0; i < len(m.HostDevices); i++ {
		if swag.IsZero(m.HostDevices[i]) { // not required
			continue
		}

		if m.HostDevices[i] != nil {
			if err := m.HostDevices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostDevices" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hostDevices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) validateInputs(formats strfmt.Registry) error {
	if swag.IsZero(m.Inputs) { // not required
		return nil
	}

	for i := 0; i < len(m.Inputs); i++ {
		if swag.IsZero(m.Inputs[i]) { // not required
			continue
		}

		if m.Inputs[i] != nil {
			if err := m.Inputs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inputs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inputs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) validateInterfaces(formats strfmt.Registry) error {
	if swag.IsZero(m.Interfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.Interfaces); i++ {
		if swag.IsZero(m.Interfaces[i]) { // not required
			continue
		}

		if m.Interfaces[i] != nil {
			if err := m.Interfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("interfaces" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) validateSound(formats strfmt.Registry) error {
	if swag.IsZero(m.Sound) { // not required
		return nil
	}

	if m.Sound != nil {
		if err := m.Sound.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sound")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sound")
			}
			return err
		}
	}

	return nil
}

func (m *V1VMDevices) validateWatchdog(formats strfmt.Registry) error {
	if swag.IsZero(m.Watchdog) { // not required
		return nil
	}

	if m.Watchdog != nil {
		if err := m.Watchdog.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("watchdog")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("watchdog")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this v1 Vm devices based on the context it is used
func (m *V1VMDevices) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDisks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFilesystems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGpus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHostDevices(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInputs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateInterfaces(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSound(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateWatchdog(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1VMDevices) contextValidateDisks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Disks); i++ {

		if m.Disks[i] != nil {

			if swag.IsZero(m.Disks[i]) { // not required
				return nil
			}

			if err := m.Disks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("disks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("disks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) contextValidateFilesystems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Filesystems); i++ {

		if m.Filesystems[i] != nil {

			if swag.IsZero(m.Filesystems[i]) { // not required
				return nil
			}

			if err := m.Filesystems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("filesystems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("filesystems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) contextValidateGpus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Gpus); i++ {

		if m.Gpus[i] != nil {

			if swag.IsZero(m.Gpus[i]) { // not required
				return nil
			}

			if err := m.Gpus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("gpus" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("gpus" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) contextValidateHostDevices(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.HostDevices); i++ {

		if m.HostDevices[i] != nil {

			if swag.IsZero(m.HostDevices[i]) { // not required
				return nil
			}

			if err := m.HostDevices[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("hostDevices" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("hostDevices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) contextValidateInputs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Inputs); i++ {

		if m.Inputs[i] != nil {

			if swag.IsZero(m.Inputs[i]) { // not required
				return nil
			}

			if err := m.Inputs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("inputs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("inputs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) contextValidateInterfaces(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Interfaces); i++ {

		if m.Interfaces[i] != nil {

			if swag.IsZero(m.Interfaces[i]) { // not required
				return nil
			}

			if err := m.Interfaces[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("interfaces" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *V1VMDevices) contextValidateSound(ctx context.Context, formats strfmt.Registry) error {

	if m.Sound != nil {

		if swag.IsZero(m.Sound) { // not required
			return nil
		}

		if err := m.Sound.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sound")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sound")
			}
			return err
		}
	}

	return nil
}

func (m *V1VMDevices) contextValidateWatchdog(ctx context.Context, formats strfmt.Registry) error {

	if m.Watchdog != nil {

		if swag.IsZero(m.Watchdog) { // not required
			return nil
		}

		if err := m.Watchdog.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("watchdog")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("watchdog")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *V1VMDevices) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1VMDevices) UnmarshalBinary(b []byte) error {
	var res V1VMDevices
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
